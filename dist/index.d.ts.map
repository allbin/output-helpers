{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","file":"index.d.ts","sourcesContent":["import moment, { Moment } from 'moment';\n\n\n\ninterface StrStrObject {\n    [key: string]: string;\n}\ntype LangId = \"sv-SE\"|\"en-US\";\ninterface Dictionary {\n    [key: string]: any;\n    \"sv-SE\"?: StrStrObject;\n    \"en-US\"?: StrStrObject;\n    prefix?: string;\n}\ninterface FormatOptions {\n    round?: number;\n    ceil?: number;\n    floor?: number;\n    fixed?: number;\n    integer_padding?: number;\n    decimal_padding?: number;\n    padding?: number;\n    trunc?: boolean;\n    grouping?: boolean;\n}\ninterface InputConfig {\n    [key: string]: any;\n    date_locale?: LangId;\n    dictionaries?: Dictionary[];\n    extend_with?: {\n        [key: string]: any\n    };\n    fallback_language?: LangId;\n    lang?: LangId;\n}\ninterface Config {\n    [key: string]: any;\n    date_locale: LangId|null;\n    dictionaries: Dictionary[];\n    extend_with: {\n        [key: string]: any\n    }|null;\n    fallback_language: LangId;\n    lang: LangId;\n}\n\n\n\n\nmoment.defineLocale('sv-SE', getDateLocale('sv-SE'));\nmoment.defineLocale('en-US', getDateLocale('en-US'));\nmoment.locale('en-US');\n\n\n\nlet translations: Dictionary = {};\n\nlet default_config: Config = {\n    date_locale: null,\n    dictionaries: [],\n    extend_with: null,\n    fallback_language: 'en-US',\n    lang: 'en-US'\n};\nlet config = Object.assign({}, default_config);\nlet supported_languages = ['sv-SE', 'en-US'];\n\n//////////////////\n//STRINGS\n\nfunction translate(str: string, capitalize: boolean = true, language: LangId|null = null, empty_on_error: boolean = false, dictionary: Dictionary|null = null) {\n    // const lang_in_jwt = (window.sso && window.sso.isLoggedIn()) ? window.sso.getJWT().getClaim(\"lang\") : config.fallback_language;\n    let lang = language || config.lang;\n    dictionary = dictionary || translations;\n\n    if (!dictionary) {\n        console.error(\"Dictionary not defined.\");\n        return str;\n    }\n\n    if (!str || str.length === 0) {\n        console.error(\"Tried to translate undefined string.\");\n        return \"\";\n    }\n\n    let translation = doTranslationCheck(str, dictionary, lang, empty_on_error);\n\n    if (capitalize === true) {\n        return capitalizeString(translation);\n    }\n    return translation;\n}\n\nfunction doTranslationCheck(key: string, dictionary: Dictionary, lang: string, empty_on_error: boolean = false) {\n    if (dictionary.hasOwnProperty(lang) === false) {\n        console.warn(\"Translation for language '\" + lang +\"' not supported, defaulting to: \" + config.fallback_language);\n        if (dictionary.hasOwnProperty(config.fallback_language) === false) {\n            console.error(\"Fallback language '\" + config.fallback_language + \"' not defined in translation library!\");\n            if (empty_on_error) {\n                return \"\";\n            }\n            return key + \"\";\n        }\n        lang = config.fallback_language;\n    }\n\n    let translation = dictionary[lang][key];\n    if (!translation) {\n        if (lang === config.fallback_language) {\n            console.error(\"No translation found for '\" + key + \"' for '\" + lang + \"' or fallback language.\");\n            if (empty_on_error) {\n                return \"\";\n            }\n            return key + \"\";\n        }\n        const dict = dictionary[config.fallback_language];\n        if (dict) {\n            translation = dict[key];\n        } else {\n            translation = undefined;\n        }\n        \n        if (!translation) {\n            console.error(\"No translation found for '\" + key + \"' for '\" + lang + \"' or fallback language.\");\n            if (empty_on_error) {\n                return \"\";\n            }\n            return key + \"\";\n        }\n\n        console.warn(\"No translation found for '\" + key + \"' for '\" + lang + \"'. Returning fallback language.\");\n    }\n\n    return translation;\n}\n\nfunction capitalizeString(str: string, force_lower:boolean = false) {\n    if (typeof str !== \"string\") { console.warn(\"Capitalize err: input not a string.\"); return \"\"; }\n    if (str.length < 1) { return \"\"; }\n\n    if (force_lower) {\n        return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();\n    }\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\n\n\n\n///////////////\n//DATE and TIME\n\nfunction formatDateAsString(d: Date|string|Moment, output_format = \"YYYY-MM-DD HH:mm\", input_format: string|null = null, utc = true) {\n    if (moment.isMoment(d)) {\n        return d.format(output_format);\n    }\n\n    if (typeof d === \"string\") {\n        if (input_format) {\n            d = (utc) ? moment.utc(d, input_format) : moment(d, input_format);\n        } else {\n            d = (utc) ? moment.utc(d) : moment(d);\n        }\n    } else if (typeof d.getMonth === 'function') {\n        d = (utc) ? moment.utc(d) : moment(d);\n    } else {\n        console.error(\"Cannot formatDateAsString; unknown format of input. moments, strings and dates are supported. Returning input.\");\n        return d + \"\"; //Force string.\n    }\n    return d.format(output_format);\n}\n\nfunction formatDateAsTimeString(d: Date|string|Moment, input_format = null, utc = true) {\n    return formatDateAsString(d, \"HH:mm\", input_format, utc);\n}\n\nfunction dateToMoment(d: Date, utc = true) {\n    if (utc) {\n        return moment.utc(d);\n    }\n    return moment(d);\n}\n\nfunction getDateLocale(language: LangId|null = null) {\n    // const lang_in_jwt = (window.sso && window.sso.isLoggedIn()) ? window.sso.getJWT().getClaim(\"lang\") : fallback_language;\n    let lang = language || config.lang;\n\n    const date_locales: {\n        [key: string]: moment.LocaleSpecification\n    } = {\n        \"sv-SE\": {\n            months: [\n                \"Januari\", \"Februari\", \"Mars\", \"April\", \"Maj\", \"Juni\", \"Juli\",\n                \"Augusti\", \"September\", \"Oktober\", \"November\", \"December\"\n            ],\n            monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"],\n            weekdays: [\"Söndag\", \"Måndag\", \"Tisdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lördag\"],\n            weekdaysShort: [\"Sön\", \"Mån\", \"Tis\", \"Ons\", \"Tor\", \"Fre\", \"Lör\"],\n            weekdaysMin: [\"Sö\", \"Må\", \"Ti\", \"On\", \"To\", \"Fr\", \"Lö\"],\n            week: {\n                dow: 1,\n                doy: 4\n            }\n        },\n        \"en-US\": {\n            months: [\n                \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\",\n                \"August\", \"September\", \"October\", \"November\", \"December\"\n            ],\n            monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n            weekdays: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n            weekdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n            weekdaysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n            week: {\n                dow: 1,\n                doy: 4\n            }\n        }\n    };\n\n    if (date_locales.hasOwnProperty(lang)) {\n        return date_locales[lang];\n    } else if (date_locales.hasOwnProperty(config.fallback_language)) {\n        console.error(\"Missing date locales for lang '\" + lang + \"', returning fallback language '\" + config.fallback_language + \"'.\");\n        return date_locales[config.fallback_language];\n    }\n    throw new Error(\"Missing date locales for lang '\" + lang + \"' and fallback language '\" + config.fallback_language + \"'. Returning null.\");\n}\n\nfunction formatSecondsToMS(value: number, alwaysInclude = \"none\", padding = false, colon = false) {\n    //Function to convert a value (seconds) to a [m]m[s]s format: 1m2s.\n    //alwaysInclude can be:\n    // \"none\" - if not enough for a minute only returns seconds, if an exact minute the seconds will not be included.\n    // \"minutes\" - if value not above 60 \"0m\" will be prepended to the seconds.\n    // \"seconds\" - if value is exact minute \"0s\" will be appended after the minute.\n    // \"both\" - Will always prepend and append \"0m\" and \"0s\" respectively as needed.\n    //padding <bool> toggles if values should be padded so 4 becomes 04. Both minutes and seconds will be padded.\n    //colon <bool> changes the format to be mm:ss instead of \"mmMssS\". Will always include both minutes and seconds, always padding.\n\n    const minutes = (value > 0) ? Math.floor(value / 60) : Math.ceil(value / 60);\n    const seconds = value % 60;\n\n    let m_str = \"\";\n    let s_str = \"\";\n\n    if (padding || colon) {\n        m_str = format(minutes, { padding: 2 });\n        s_str = format(seconds, { padding: 2 });\n    } else {\n        m_str = minutes + \"\"; //Ensure string.\n        s_str = seconds + \"\"; //Ensure string.\n    }\n\n    if (colon) {\n        return m_str + \":\" + s_str;\n    }\n\n    if (alwaysInclude === \"none\") {\n        if (minutes !== 0 && seconds !== 0) {\n            return m_str + \"m\" + s_str + \"s\";\n        } else if (minutes === 0) {\n            return s_str + \"s\";\n        }\n        return m_str + \"m\";\n    } else if (alwaysInclude === \"minutes\") {\n        if (seconds !== 0) {\n            return m_str + \"m\" + s_str + \"s\";\n        }\n        return m_str + \"m\";\n    } else if (alwaysInclude === \"seconds\") {\n        if (minutes !== 0) {\n            return m_str + \"m\" + s_str + \"s\";\n        }\n        return s_str + \"s\";\n    }\n    return m_str + \"m\" + s_str + \"s\";\n}\n\n\n\n\n\n\n////////////////\n//Numeric\n\nfunction roundTo(input: number, round_exp: number = 0) {\n    if (round_exp === 0) { return Math.round(input); }\n    let stringified: string[] = [\"\"];\n    stringified = input.toString().split('e');\n    let round = Math.round(+(stringified[0] + 'e' + (stringified[1] ? (+stringified[1] - round_exp) : -round_exp)));\n    stringified = round.toString().split('e');\n    return +(stringified[0] + 'e' + (stringified[1] ? (+stringified[1] + round_exp) : round_exp));\n}\n\nfunction roundUpTo(input: number, ceil_exp: number = 0) {\n    if (ceil_exp === 0) { return Math.ceil(input); }\n    let stringified: string[] = [\"\"];\n    stringified = input.toString().split('e');\n    let ceil = Math.ceil(+(stringified[0] + 'e' + (stringified[1] ? (+stringified[1] - ceil_exp) : -ceil_exp)));\n    stringified = ceil.toString().split('e');\n    return +(stringified[0] + 'e' + (stringified[1] ? (+stringified[1] + ceil_exp) : ceil_exp));\n}\n\nfunction roundDownTo(input: number, floor_exp: number = 0) {\n    if (floor_exp === 0) { return Math.floor(input); }\n    let stringified: string[] = [\"\"];\n    stringified = input.toString().split('e');\n    let floor = Math.floor(+(stringified[0] + 'e' + (stringified[1] ? (+stringified[1] - floor_exp) : -floor_exp)));\n    stringified = floor.toString().split('e');\n    return +(stringified[0] + 'e' + (stringified[1] ? (+stringified[1] + floor_exp) : floor_exp));\n}\n\ninterface FormatOptions {\n    round?: number;\n    ceil?: number;\n    floor?: number;\n    integer_padding?: number;\n    decimal_padding?: number;\n    padding?: number;\n    trunc?: boolean;\n    grouping?: boolean;\n}\n\nfunction format(value: number, options: FormatOptions) {\n    let str: string;\n    let str_arr: string[];\n    const round = (typeof options.round === \"number\") || false;\n    const round_exp = options.round;\n    const ceil = (typeof options.ceil === \"number\") || false;\n    const ceil_exp = options.ceil;\n    const floor = (typeof options.floor === \"number\") || false;\n    const floor_exp = options.floor;\n    const separate_padding = (typeof options.integer_padding === \"number\" || typeof options.decimal_padding === \"number\") || false;\n    const i_pad_length = options.integer_padding;\n    const d_pad_length = options.decimal_padding;\n    const padding = (typeof options.padding === \"number\") || false;\n    const pad_length = options.padding;\n    const trunc = (options.trunc === true) || false;\n    const grouping = (options.grouping === true) || false;\n\n    const is_negative = (value < 0);\n\n    if (typeof value !== \"number\") {\n        console.warn(\"Tried to format a value but input was typeof: \", typeof value);\n        return value;\n    }\n\n    if (round && !ceil && !floor) {\n        value = roundTo(value, round_exp);\n    }\n    if (ceil && !floor) {\n        value = roundUpTo(value, ceil_exp);\n    }\n    if (floor) {\n        value = roundDownTo(value, floor_exp);\n    }\n\n    if (trunc && !round) {\n        str = Math.trunc(value).toString();\n    } else {\n        str = value.toString();\n    }\n\n    if (grouping) {\n        if (is_negative) { //Remove minus sign if negative.\n            str = str.substr(1);\n        }\n        let separated = str.split('.'); //We only want to group the value before the decimal point.\n        str_arr = separated[0].split('');\n        str = \"\";\n        while (str_arr.length > 3) {\n            str = \" \" + str_arr[str_arr.length - 3] + str_arr[str_arr.length - 2] + str_arr[str_arr.length - 1] + str;\n            str_arr = str_arr.slice(0, str_arr.length - 3);\n        }\n        let joined_arr = str_arr.join(\"\");\n        str = (joined_arr.length > 0) ? joined_arr + str : str;\n        str += (separated.length > 1) ? \".\" + separated[1] : \"\";\n        if (is_negative) { //Add minus sign if negative.\n            str = \"-\" + str;\n        }\n    }\n\n    if (separate_padding) {\n        str_arr = str.split(\".\");\n        if (i_pad_length && str_arr[0].length < i_pad_length) {\n            str_arr[0] = (\"000000000000000000000\" + str_arr[0]).slice(-i_pad_length);\n        }\n        if (d_pad_length) {\n            if (str_arr.length > 1 && str_arr[1].length < d_pad_length) {\n                str_arr[1] = (str_arr[1] + \"000000000000000000000\").slice(0, d_pad_length);\n                str_arr.join(\".\");\n            } else if (str_arr.length > 1) {\n                str = str_arr[0] + \".\" + (str_arr[1] + \"00000000000000000\").slice(0, d_pad_length);\n            } else {\n                str = str_arr[0] + \".\" + \"00000000000000000\".slice(0, d_pad_length);\n            }\n        }\n    }\n    if (padding && pad_length) {\n        if (str.length < pad_length) {\n            str = (str + \"000000000000000000000\").slice(0, pad_length);\n        }\n    }\n\n    return str;\n}\n\n\n\n\n\n\nfunction updateTranslations(dictionary_arr: Dictionary[], warn = true, overwrite = true) {\n    translations = {};\n    dictionary_arr.forEach((dict: Dictionary, dict_index: number) => {\n        let prefix = dict.hasOwnProperty('prefix') ? dict.prefix : \"\";\n        let keys = Object.keys(dict);\n        keys.forEach((potential_lang) => {\n            if (supported_languages.includes(potential_lang) === false) {\n                return;\n            }\n            let lang = potential_lang as LangId;\n            const lang_in_dict = dict[lang];\n            if (!lang_in_dict) { return; }\n            let keys_for_lang: string[] = Object.keys(lang_in_dict);\n            if (translations.hasOwnProperty(lang) === false) {\n                let new_lang_translations: StrStrObject = {};\n                keys_for_lang.forEach((key) => {\n                    new_lang_translations[prefix + key] = lang_in_dict[key];\n                });\n                translations[lang] = new_lang_translations;\n            } else {\n                if (warn || !overwrite) {\n                    let updated_lang_translations = Object.assign({}, translations[lang]);\n                    \n                    keys_for_lang.forEach((translation_key) => { \n                        if (updated_lang_translations.hasOwnProperty(prefix + translation_key)) {\n                            if (warn) {\n                                console.warn(\"OH: Dictionary \" + dict_index + \" is conflicting with existing key '\" + (prefix + translation_key) + \"'.\");\n                            }\n                            if (overwrite) {\n                                updated_lang_translations[prefix + translation_key] = lang_in_dict[translation_key];\n                            }\n                        }\n                        updated_lang_translations[prefix + translation_key] = lang_in_dict[translation_key];\n                    });\n                    translations[lang] = updated_lang_translations;\n                } else {\n                    let new_lang_translations: StrStrObject = {};\n                    keys_for_lang.forEach((key) => {\n                        new_lang_translations[prefix + key] = lang_in_dict[key];\n                    });\n                    translations[lang] = Object.assign({}, translations[lang], new_lang_translations);\n                }\n            }\n        });\n    });\n}\n\nfunction addDictionary(dictionary: Dictionary) {\n    config.dictionaries.push(dictionary);\n    updateTranslations(config.dictionaries);\n}\n\nlet funcs = {\n    addDictionary: addDictionary,\n    dateToMoment: dateToMoment,\n    format: format,\n    formatDateAsString: formatDateAsString,\n    formatDateAsTimeString: formatDateAsTimeString,\n    formatSecondsToMS: formatSecondsToMS,\n    getCurrentConfig: getCurrentConfig,\n    getDateLocale: getDateLocale,\n    getFallbackLang: getFallbackLang,\n    getLang: getLang,\n    roundDownTo: roundDownTo,\n    roundTo: roundTo,\n    roundUpTo: roundUpTo,\n    setConfig: setConfig,\n    translate: translate,\n};\n\nlet exported_funcs = Object.assign({}, funcs);\n\nfunction setConfig(config_opts: InputConfig) {\n    let invalid = false;\n    Object.keys(config_opts).forEach((key) => {\n        if (key === \"dictionaries\" && config.dictionaries.length > 0) {\n            console.warn(\"OH: To add dictionaries after initial setConfig use 'OH.addDictionary()'\");\n            invalid = true;\n            return;\n        }\n        if (config[key] !== default_config[key]) {\n            console.warn(\"OH: setConfig has overwritten previous setting '\" + key + \"': \" + config[key] + \" => \" + config_opts[key]);\n        }\n    });\n    if (invalid) {\n        console.error(\"OH: Unable to setConfig, invalid settings.\");\n        return;\n    }\n    config = Object.assign({}, config, config_opts);\n\n    if (!config.lang) {\n        console.warn(\"OH: No lang specified with setConfig, defaulting to fallback language: \" + config.fallback_language + \".\");\n        config.lang = config.fallback_language;\n    }\n    if (config.date_locale) {\n        moment.locale(config.date_locale);\n    } else {\n        moment.locale(config.lang);\n    }\n    if (Array.isArray(config.dictionaries) === false) {\n        console.error(\"OH: 'dictionaries' prop required to be an array.\");\n        config.dictionaries = [];\n        translations = {};\n    }\n\n    updateTranslations(config.dictionaries);\n    exported_funcs = Object.assign(exported_funcs, config.extend_with, funcs);\n}\n\nfunction getCurrentConfig() {\n    return Object.assign({}, config);\n}\n\nfunction getLang() {\n    return config.lang;\n}\nfunction getFallbackLang() {\n    return config.fallback_language;\n}\n\n\n\nexport default exported_funcs;"]}